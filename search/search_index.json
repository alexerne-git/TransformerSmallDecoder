{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Decoder-Only Transformer Architecture","text":""},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction </li> <li>Architecture Overview </li> <li>Input Tokens, Embedding, and Positional Encoding </li> <li>Decoder Model <ul> <li>4.1. Masked Multi-Head Attention </li> <li>4.2. Add &amp; Norm </li> <li>4.3. Feed-Forward Neural Network (FFNN) </li> <li>4.4. Add &amp; Norm </li> <li>4.5. Full Decoder Block </li> </ul> </li> <li>Linear Layer </li> <li>Training Pipeline <ul> <li>6.1. Flattening and Loss Computation </li> <li>6.2. Updating Learnable Weights </li> <li>6.3. Loss Computation During Training</li> </ul> </li> <li> <p>Inference Pipeline </p> <ul> <li>7.1. Input Preparation </li> <li>7.2. Autoregressive Token Prediction </li> <li>7.3. Iterative Process </li> </ul> </li> <li> <p>Additionals: Vanishing gradients and regularization techniques</p> </li> <li>References</li> </ol>"},{"location":"#1-introduction","title":"1. Introduction","text":"<p>The goal of this readme is to describe in details the Transformer Decoder Architecture. We will be presenting all the different layers and illustrating each step using a dummy example. </p>"},{"location":"#2-architecture-overview","title":"2. Architecture Overview","text":"<p>The Decoder only architecture contains multiple concepts, that we will see in detail. To begin, we will lay the general overview of the pipeline, mentionning all the core components. </p> <p>The Decoder architecture is built upon many different components, namely (and in order):</p> <ul> <li>Input Tokens These represent the tokens processed by the model. During training, they are batches of input sequences from the dataset. During inference, they refer to the input text provided to the model.</li> <li>Input Embeddings Tokens are mapped to dense vector rpz. using an embedding matrix, capturing semantic relationships.</li> <li>Positional Encoding is added to the embeddings, enabling the model to understand the order of tokens in a sequence.</li> <li>Decoder block<ul> <li>Masked Multi-Head Attention Computes attention scores to capture contextual relationships between tokens. Masking ensures that the model only considers past and current tokens during training.</li> <li>Norm and Add Layer normalization first, followed by a residual connection to stabilize training and improve gradient flow.</li> <li>Feed Forward Neural Network Fully connected network with a non-linear activation for learning complex relationships.</li> <li>Add &amp; Norm Layer normalization first, followed by a residual connection after the feed-forward network.</li> </ul> </li> <li>Linear Layer Projects the output matrix from the decoder block to a space matching the vocabulary size, producing logits.</li> <li>Softmax Converts logits into probabilities, representing the likelihood of each token in the vocabulary.</li> <li>Output probabilities The probabilities of tokens in the sequence generated by the model.</li> </ul>"},{"location":"#3-input-tokens-embedding-and-positional-encoding","title":"3. Input Tokens, Embedding, and Positional Encoding","text":"<p>The first step of the model begins with processing the input tokens, also called tokenization.</p> <ul> <li> <p>Input Tokens: Tokenization consists of splitting text into smaller units or tokens. There exist various strategies, such as character-level tokenization, word-level tokenization, subword tokenization (like Open AI models using with Byte Pair Encoding). This allows to create a vocabulary, containing all unique tokens which are mapped to unique IDs.</p> </li> <li> <p>Input Embedding Matrix: The tokens are then mapped to a dense vector representation, also called the embedding matrix. This matrix is learnable and is optimized during training through backpropagation.  It is of shape <code>(vocab_size, n_embed)</code>, where <code>vocab_size</code> is the total number of tokens in the vocabulary and <code>n_embed</code> is the embedding dimension. This matrix is essential for the Decoder as it allows to capture semantic relationships between tokens. </p> </li> <li> <p>Positional Encoding Matrix:  Positional Encoding is added to the token embeddings to provide the model with information about token positions in the sequence. It is of shape <code>(block_size, n_embed)</code>, where <code>block_size</code> is the sequence length and <code>n_embed</code> is the embedding dimension. One important note is that the positional encoding ensures that tokens at the same positions in different sequences receive the same positional embedding, as it is only based on their position within the sequence. Finally, this positional encoding, unlike the one used in the original Transformer paper, is based on learned embeddings, which is also optimized during training. </p> </li> <li> <p>Combined Input Matrix: The Input Embedding Matrix and Positional Embedding Matrix are added together to form the input matrix for the model, allowing both semantic and positional information to be incorporated.</p> </li> </ul>"},{"location":"#example","title":"Example:","text":"<p>For the following explanation, we use this example dataset:  </p> <ul> <li>Input Dataset: <code>\"dog jumps around cat man is helping cat\"</code> </li> <li>Tokenization: <code>[\"dog\", \"jumps\", \"around\", \"cat\", \"man\", \"is\", \"helping\", \"cat\"]</code> </li> <li>Unique IDs: <code>{\"cat\": 0, \"dog\": 1, \"jumps\": 2, \"around\": 3, \"man\": 4, \"is\": 5, \"helping\": 6}</code> </li> <li>Vocabulary Size (<code>vocab_size</code>): <code>7</code> </li> <li>Embedding Dimension (<code>C</code>): <code>6</code> </li> <li>Block Size (<code>T</code>): <code>4</code> </li> <li>Batch Size (<code>B</code>): <code>2</code> </li> </ul> <p>1. Input Representation:</p> <p>The model's input is a tensor of shape <code>(B, T) = (2, 4)</code>, as depicted on the image:</p> <p>2. Embedding Tables:</p> <ul> <li>Token Embedding Table: Shape <code>(vocab_size, n_embed) = (7, 6)</code> </li> <li>Positional Embedding Table: Shape <code>(block_size, n_embed) = (4, 6)</code> </li> </ul> <p>3. Embedding Process:</p> <ol> <li>Input Embedding Matrix (<code>tok_emb</code>): Maps the input tokens <code>(B, T)</code> to a dense matrix of shape <code>(B, T, C) = (2, 4, 6)</code>.  </li> <li>Final Input Matrix (<code>x</code>): The positional encoding matrix <code>(4, 6)</code> is added (via broadcasting) to the token embedding matrix, resulting in a final shape of <code>(B, T, C) = (2, 4, 6)</code>.</li> </ol>"},{"location":"#4-decoder","title":"4. Decoder:","text":""},{"location":"#41-masked-multi-head-attention","title":"4.1. Masked Multi-Head Attention","text":"<p>Multi-Head Attention consists of multiple attention \"heads\" each processing the input independently to capture different aspects of relationships between tokens (e.g., semantic, syntactic). Each head operates in parallel, enabling the model to simultaneously attend various parts of the input sequence. The results from all heads are concatenated and transformed into a single output. However, more heads are not always better; their effectiveness depends on the model's capacity (embedding dimensions per head) and the complexity of the task.</p> <p>1. Key Components</p> <p>Each attention head computes attention scores using three vectors derived from the input:</p> <ul> <li>Query (<code>Q</code>): Represents the token currently being processed.</li> <li>Key (<code>K</code>): Acts as a label for other tokens in the sequence.</li> <li>Value (<code>V</code>): Encodes the actual information of each token.</li> </ul> <p>These vectors are generated by applying separate linear transformations with learned weights:</p>  Q = XW_Q, \\quad K = XW_K, \\quad V = XW_V  <ul> <li> X : The input embeddings of shape (B, T,C)</li> <li> W_Q, W_K, W_V : Learnable weight matrices of shapes (C, d_k), (C, d_k), and (C, d_v), respectively, used to project the input embeddings into Query, Key, and Value vectors. (in_features, out_features)</li> </ul> <p>Note: In PyTorch, weight matrices like  W_Q, W_K, W_V  are defined in the shape (\\text{out_features}, \\text{in_features}). During computation, the transpose is applied implicitly, making the operation  Q = XW_Q  mathematically equivalent to  Q = XW_Q^T , without requiring an explicit transpose. </p> <p>2. Attention Score Calculation</p> <p>Determines how much focus each token should have on others in the sequence using the Scaled Dot-Product Attention formula: $$ \\text{Attention}(Q, K, V) = \\text{softmax}\\left(\\frac{QK^T}{\\sqrt{d_k}}\\right)V $$</p> <ul> <li>QK^T: Computes the similarity between the Query and Key vectors (dot product).</li> <li>\\sqrt{d_k}: A scaling factor to stabilize the attention scores where d_k = \\frac{n_{\\text{embed}}}{\\text{num_heads}}.</li> <li>\\text{softmax}: Normalizes the attention scores into probabilities.  </li> <li>V: Represents the values aggregated using the attention probabilities.</li> </ul> <p>3. Masking in the Decoder</p> <p>To ensure causal (sequential) behavior, masking is applied in the decoder:</p> <ul> <li>Why Masking?  During token prediction, the decoder must not \"peek\" at future tokens or the rest of the target sequence. Masking ensures only previous and current tokens are visible.</li> <li>How Masking Works: <ul> <li>A mask is applied to the attention scores before the softmax step.</li> <li>Masked positions are set to -\\infty, forcing their softmax values to be zero.</li> </ul> </li> </ul> <p>4. Final Output:</p> <p>Each attention head produces an output of shape <code>(B, T, d_k)</code>. Outputs from all heads are concatenated into a single matrix and passed through a linear layer to produce the final output of shape <code>(B, T, C)</code>, where <code>C</code> is the model's embedding size.</p>"},{"location":"#example_1","title":"Example:","text":"<p>Using the previous example with the following parameters:  </p> <ul> <li>Batch size <code>B = 2</code> </li> <li>Block size <code>T = 4</code> </li> <li>Embedding dimension <code>C = 6</code> </li> <li>Number of heads = <code>3</code> </li> </ul> <p>For simplicity, we omit the \\sqrt{d_k} scaling factor.</p> <p>Step-by-Step Process:</p> <ol> <li> <p>Input Dimensions:  Input embeddings have shape <code>(B, T, C) = (2, 4, 6)</code>.  </p> </li> <li> <p>Query, Key, and Value Matrices </p> <ul> <li>Three linear transformations produce <code>Q</code>, <code>K</code>, and <code>V</code>.</li> <li>Each matrix has shape <code>(B, T, h_s) = (2, 4, 2)</code>, where <code>h_s</code> (head size) is <code>C</code> divided by the number of heads: <code>6/3 = 2</code>.</li> <li>Weight matrices for <code>Q</code>, <code>K</code>, and <code>V</code> are of shape <code>(h_s, C)</code>.</li> </ul> </li> <li> <p>Attention Score Computation </p> <ul> <li>Compute the dot product of <code>Q</code> and <code>K^T</code>, resulting in the attention score matrix <code>wei</code> of shape <code>(B, T, T) = (2, 4, 4)</code>.</li> <li>Apply masking and softmax to normalize the scores.</li> </ul> </li> <li> <p>Attention Output </p> <ul> <li>Multiply the attention scores with <code>V</code>, yielding an output matrix for each head of shape <code>(B, T, h_s) = (2, 4, 2)</code>.</li> </ul> </li> <li> <p>Head Concatenation </p> <ul> <li>Concatenate the outputs from all 3 heads to form a single matrix of shape <code>(B, T, C) = (2, 4, 6)</code>.</li> </ul> </li> </ol> <p>This final matrix is the output of the masked multi-head attention layer. This is illustrated in the following image:</p> <p>Simplified Example:</p> <p>We start with the input matrix <code>(B, T, C) = (2, 4, 6)</code>. To focus on a single sequence, we reduce it to <code>(T, C) = (4, 6)</code>. For simplicity, we further reduce the embedding dimension to <code>C = 2</code>, giving <code>(T, C) = (4, 2)</code>. The head size is set to <code>h_s = 2</code>.</p> <p>Disclaimer: This process is applied simultaneously across all sequences in the batch, but this illustration focuses on what happens for a single sequence for clarity. In practice, it operates on all sequences independently within the batch.</p> <ol> <li> <p>Query Matrix (<code>Q</code>):  </p> <ul> <li>Input <code>X</code>: <code>(T, C) = (4, 2)</code>, Weight <code>W_Q</code>: <code>(C, h_s) = (2, 2)</code> </li> <li>Result: <code>Q = (T, h_s) = (4, 2)</code></li> </ul> </li> <li> <p>Key Matrix (<code>K</code>):  </p> <ul> <li>Weight <code>W_K</code>: <code>(C, h_s) = (2, 2)</code> </li> <li>Result: <code>K = (T, h_s) = (4, 2)</code></li> </ul> </li> <li> <p>Attention Scores:  </p> <ul> <li><code>Q</code>: <code>(T, h_s) = (4, 2)</code>, <code>K^T</code>: <code>(h_s, T) = (2, 4)</code> </li> <li>Result: <code>QK^T = (T, T) = (4, 4)</code> </li> <li>Each token in the query is evaluated against all tokens in the key (which act as labels) to compute attention scores.</li> </ul> </li> <li> <p>Softmax:  </p> <ul> <li>Apply softmax to normalize <code>QK^T</code>, keeping the shape: <code>(T, T) = (4, 4)</code></li> </ul> </li> <li> <p>Value Matrix (<code>V</code>):  </p> <ul> <li>Weight <code>W_V</code>: <code>(C, h_s) = (2, 2)</code> </li> <li>Result: <code>V = (T, h_s) = (4, 2)</code></li> </ul> </li> <li> <p>Contextualized Output:  </p> <ul> <li>Multiply attention scores with <code>V</code>:  <code>(T, T) \\cdot (T, h_s) = (4, 4) \\cdot (4, 2)</code> </li> <li>Result: <code>Output = (T, h_s) = (4, 2)</code> </li> <li>The attention scores are used to aggregate values  V , producing the final contextualized embeddings.</li> </ul> </li> </ol> <p>Final Output: The final contextualized embedding for the sequence has shape: <code>(T, h_s) = (4, 2)</code>.  </p> <p>This process computes how much focus each token in the sequence should give to every other token, combining the values  V  weighted by the attention scores to produce the output.</p>"},{"location":"#42-norm-add-pre-norm","title":"4.2. Norm &amp; Add (Pre-norm)","text":"<p>Norm &amp; Add is an essential step in the Transformer Decoder architecture, combining layer normalization and residual connections to stabilize and enhance the training process. Here, Layer Normalization is applied before the sublayer, independently to each token embedding across its feature dimensions.</p> <p>Key Steps:</p> <ol> <li> <p>Layer Normalization (Norm):</p> <ul> <li>The input to the Masked Multi-Head Attention (or Feed-Forward Network in subsequent steps) is normalized first.  </li> <li>This step ensures stability by normalizing the intermediate activations across the feature dimensions to have a consistent mean and variance.</li> </ul> </li> <li> <p>Residual Connection (Add):</p> <ul> <li>The output of the sublayer (e.g., Masked Multi-Head Attention or Feed-Forward Network) is added to the input of the respective layer (e.g., input embeddings or intermediate outputs).  </li> <li>This \"shortcut\" helps retain original input information, improves gradient flow, and mitigates issues like vanishing gradients.</li> </ul> </li> </ol> <p>Why Norm &amp; Add?</p> <ol> <li> <p>Normalization Benefits:</p> <ul> <li>Prevents instability caused by vanishing or exploding gradients.</li> <li>Stabilizes training by keeping activations consistent across layers.</li> </ul> </li> <li> <p>Residual Connection Benefits:</p> <ul> <li>Preserves the input information for better gradient flow.  </li> <li>Allows the model to build upon previously learned features without discarding them.</li> </ul> </li> </ol> <p>Note: While post-norm (Add &amp; Norm) is another approach where normalization is applied after the sublayer, pre-norm (Norm &amp; Add) is typically used in decoder models as it ensures better gradient flow and training stability, especially in deep architectures.</p> <p>Layer Normalization</p> <p>The layer normalization is applied for each token independently across its embedding dimensions. This is achieved using the following formula:</p>  Norm(x) = \\frac{x - \\mathbb{E}[x]}{\\sqrt{\\text{Var}[x] + \\epsilon}} \\cdot \\gamma + \\beta  <ul> <li><code>x</code>: Original activation values.  </li> <li><code>E[x]</code>: Mean of the activations, computed across the embedding dimensions.  </li> <li><code>Var[x]</code>: Variance of the activations.  </li> <li><code>\u03b5</code>: A small constant to prevent division by zero.  </li> <li><code>\u03b3</code>: Learnable scaling parameter (initialized to 1).  </li> <li><code>\u03b2</code>: Learnable bias parameter (initialized to 0).  </li> </ul> <p>This process ensures that the normalized activations have a mean of 0 and a standard deviation of 1. The learnable parameters \\gamma and \\beta provide flexibility, allowing the model to scale and shift the normalized values to better fit the task during training.</p>"},{"location":"#43-feed-forward-neural-network-ffnn","title":"4.3 Feed-Forward Neural Network (FFNN)","text":"<p>The Feed-Forward Neural Network (FFNN) applies a pointwise transformation independently to each token's embedding dimension (much like in Linear Normalization) It processes each token vector through a small neural network comprising two linear layers separated by a non-linear activation function.</p> <ol> <li> <p>Input Dimensions:  input (B, T, C)</p> </li> <li> <p>First Linear Layer:  </p> <ul> <li>Maps the input vectors (C-dimensional) to a higher-dimensional space (D = 4C).  </li> <li>The transformation is defined as:  $$  \\text{Output}_1 = X W_1 + b_1  $$</li> <li>W_1: Weight matrix of shape (C, D).  </li> <li>Resulting output: (B, T, D).  </li> </ul> </li> <li> <p>Non-Linear Activation:  </p> <ul> <li>Applies a non-linear activation function (ReLU):  $$  \\text{Activated Output} = \\text{ReLU}(\\text{Output}_1)  $$</li> </ul> </li> <li> <p>Second Linear Layer:  </p> <ul> <li>Reduces the dimensionality back to C:  $$  \\text{Output}_2 = \\text{Activated Output} W_2 + b_2  $$</li> <li>W_2: Weight matrix of shape (D, C).  </li> <li>Resulting output: (B, T, C).  </li> </ul> </li> <li> <p>Dropout:  </p> <ul> <li>A dropout layer is applied to the output of the second linear layer to regularize the model and prevent overfitting.</li> </ul> </li> </ol> <p>Advantages of FFNN:</p> <ul> <li>D = 4C ensures the model captures richer, more complex representations.  </li> <li>Dropout improves generalization during training.</li> </ul>"},{"location":"#example_2","title":"Example:","text":"<ol> <li>Input shape:  (B, T, C) = (1, 4, 6) .  </li> <li>The first linear layer (hidden) expands to  (1, 4, 4C) = (1, 4, 24) .  </li> <li>Apply ReLU activation.  </li> <li>The second linear layer reduces back to  (1, 4, C) = (1, 4, 6) .  </li> </ol> <p>When computing gradients during backpropagation, we go backward through the network, layer by layer, updating weights based on the gradient of the loss function. ReLU helps prevent gradients from vanishing by keeping gradients for positive inputs strong and setting gradients for inactive neurons (negative inputs) to zero, ensuring effective optimization. Basically, negative values don't contribute much, and small values lead to very small gradients (which slows learning). </p>"},{"location":"#44-norm-add-pre-norm","title":"4.4 Norm &amp; Add (Pre-Norm)","text":"<p>After the Feed-Forward Neural Network (FFNN) step, the input undergoes the Norm &amp; Add process, ensuring stability and efficient gradient flow through the network.</p> <p>The output of the FFNN is added back to the input:</p>  \\text{Output}_{\\text{final}} = \\text{Input} + \\text{FFNN Output}  <p>This Norm &amp; Add process ensures smooth training by stabilizing activations and maintaining efficient gradient flow.</p>"},{"location":"#45-full-decoder-block","title":"4.5. Full Decoder Block:","text":"<p>To build the full decoder-only Transformer block, we combine the following components:</p> <ol> <li>Masked Multi-Head Attention: Captures contextual relationships between tokens while respecting causality.</li> <li>Norm and Add: Applies layer normalization and residual connection to stabilize training.</li> <li>Feed-Forward Neural Network (FFNN): Introduces non-linear transformations to learn complex patterns.</li> <li>Norm and Add: Another layer normalization and residual connection after the FFNN.</li> </ol> <p>The input and output shapes remain the same ((B, T, C)), but the model is now trained on sequences of batches, learning to process and generate sequences effectively.</p>"},{"location":"#5-linear-layer","title":"5. Linear Layer","text":"<p>At the end of the decoder stack, the output is a tensor of shape (B, T, C) This tensor needs to be mapped to logits over the vocabulary, which is achieved using the Linear Layer.</p> <ul> <li>The Linear Layer projects the decoder output from shape (B, T, C) to (B, T, \\text{vocab_size}).  </li> <li>Each element in the vocab_size dimension represents the raw score (logit) for a unique word in the vocabulary.</li> </ul> <p>After the Linear Layer, the process differs depending on whether the model is in training or inference mode:  </p> <ul> <li>During Training: The logits are used to compute the loss by comparing predicted probabilities with the target labels.  </li> <li>During Inference: The logits are used to generate the next token</li> </ul>"},{"location":"#example_3","title":"Example:","text":"<ul> <li>Input shape: (B, T, C) = (2, 4, 6).  </li> <li>Vocabulary size: \\text{vocab_size} = 7.  </li> <li>Output shape after the linear layer: (B, T, \\text{vocab_size}) = (2, 4, 7).</li> </ul> <p>For a sequence like <code>\"dog jumps around cat\"</code>, each word in the sequence is mapped to every word in the vocabulary, providing unnormalized scores (logits) for all vocabulary words. For example:</p> <ul> <li> <p>First word <code>\"dog\"</code> produces unnormalized scores for all vocabulary words:</p> </li> <li> <p>\\text{dog, cat} (logit: 2.3),</p> </li> <li>\\text{dog, dog} (logit: 4.1),</li> <li>\\text{dog, jumps} (logit: 1.8),</li> <li>\\text{dog, around} (logit: 3.0),</li> <li>\\text{dog, man} (logit: 0.5),</li> <li>\\text{dog, is} (logit: -1.2),</li> <li>\\text{dog, helping} (logit: -0.8).  </li> </ul> <p>These unnormalized scores are the raw output of the final linear layer before applying softmax. This process is repeated for every token in the sequence.</p>"},{"location":"#6-training-pipeline","title":"6. Training Pipeline","text":"<p>After the Linear Layer projects the decoder output to logits of shape (B, T, \\text{vocab_size}), the following steps occur during training*:</p>"},{"location":"#61-flattening-cross-entropy-loss-backpropagation","title":"6.1. Flattening, Cross-Entropy Loss, Backpropagation","text":"<p>1. Flattening</p> <ul> <li>The logits are reshaped from (B, T, \\text{vocab_size}) to (B \\cdot T, \\text{vocab_size}), creating a 2D matrix suitable for loss computation.  </li> <li>The target labels are flattened from (B, T) to (B \\cdot T), aligning with the logits.</li> </ul> <p>2. Cross-Entropy Loss</p> <ul> <li>The Softmax function is applied to the logits to convert them into probabilities:</li> </ul>  P_i = \\frac{\\exp(\\text{logit}_i)}{\\sum_{j=1}^{\\text{vocab_size}} \\exp(\\text{logit}_j)}  <ul> <li> P_i  is the probability of the i-th token.</li> <li> \\text{logit}_i  is the logit (raw score) for the i-th token.</li> <li>The denominator sums the exponentials of all logits across the vocabulary</li> </ul> <p>Note: In PyTorch, the Cross-Entropy Loss computes the softmax internally</p> <p>The Cross-Entropy Loss is then computed as:   $$   \\text{Loss} = -\\frac{1}{N} \\sum_{i=1}^N \\log P_{\\text{target}_i}   $$</p> <ul> <li>N = B \\cdot T: Total number of tokens in the batch.</li> <li>P_{\\text{target}_i}: Predicted probability of the target token.</li> </ul>"},{"location":"#example_4","title":"Example:","text":"<p>3. Compute Gradients and Update Weights</p>"},{"location":"#gradient-computation-backpropagation","title":"Gradient Computation (Backpropagation):","text":"<ul> <li>During the forward pass, the model computes the loss.</li> <li>Backpropagation calculates the gradients of the loss with respect to the model's weights:   $$   \\text{gradients} = \\frac{\\partial \\text{Loss}}{\\partial W}   $$</li> <li>These gradients show how much each weight contributes to the loss.</li> <li>The gradients are stored in the <code>.grad</code> attribute of each weight.</li> </ul>"},{"location":"#weight-update-optimizer","title":"Weight Update (Optimizer):","text":"<ul> <li>Using the computed gradients, the optimizer updates the model's weights.</li> <li>The optimizer applies the update rule (e.g., for Adam or SGD):   $$   W_{\\text{new}} = W_{\\text{old}} - \\eta \\cdot \\frac{\\partial \\text{Loss}}{\\partial W}   $$</li> <li>W_{\\text{new}}: Updated weight.  </li> <li>W_{\\text{old}}: Current weight.  </li> <li>\\eta: Learning rate.</li> </ul>"},{"location":"#62-learnable-weights-update","title":"6.2. Learnable Weights Update","text":"<ol> <li> <p>Embedding Weights:</p> <ul> <li>Token Embedding Table: Maps tokens to embeddings.</li> <li>Positional Embedding Table: Provides positional encodings.</li> </ul> </li> <li> <p>Attention Weights:</p> <ul> <li>Query, Key, Value Weight Matrices: W_Q, W_K, W_V for attention computation.</li> <li>Final Projection Matrix: Aggregates multi-head attention outputs.</li> </ul> </li> <li> <p>FFNN Weights:</p> <ul> <li>First Linear Layer: Weights W_1 and bias b_1.</li> <li>Second Linear Layer: Weights W_2 and bias b_2.</li> </ul> </li> <li> <p>Layer Normalization Weights:</p> <ul> <li>Scaling parameter: \\gamma.</li> <li>Shifting parameter: \\beta.</li> </ul> </li> <li> <p>Linear Layer Weights:</p> <ul> <li>Weight matrix and bias used in the final projection to logits.</li> </ul> </li> </ol> <p>Note: The optimizer updates all these weights during the optimization step, using the gradients computed via backpropagation.</p>"},{"location":"#63-loss-computation-during-training","title":"6.3. Loss Computation During Training","text":"<p>During training, the loss is computed for the entire batch by aggregating the errors across all tokens in all sequences within the batch and averaging them. This single loss value represents the overall error for the batch. The loss is then used to update the model's weights through backpropagation, optimizing the network to minimize future errors.</p> <p>To monitor performance, the loss on validation data is also computed periodically (e.g., after a certain number of iterations). During this step, the model is set to evaluation mode (using <code>model.eval()</code>) to ensure that weights are not modified and that behaviors like dropout are disabled. This helps assess how well the model generalizes to unseen data without impacting the training process.</p>"},{"location":"#7-inference-pipeline","title":"7. Inference Pipeline","text":"<p>In generation mode, the model predicts one token at a time, iteratively building the output sequence using weights and embeddings learned during training, which allows the model to generate coherent and context-aware text outputs.</p>"},{"location":"#71-input-preparation","title":"7.1. Input Preparation","text":"<ol> <li> <p>User Input:The process begins with an input sequence or prompt (e.g., <code>\"dog\"</code>).</p> </li> <li> <p>Tokenization, Embedding, Positional Encodings:</p> <ul> <li>The input is tokenized and mapped to token indices.</li> <li>These indices are passed through the learned embedding matrix to produce an embedding tensor of shape (B,T,C)</li> <li>Positional encodings (learned during training) are added to the token embeddings.</li> </ul> </li> </ol>"},{"location":"#72-autoregressive-token-prediction","title":"7.2. Autoregressive Token Prediction","text":"<ol> <li> <p>Passing Through the Model:The input tensor  (B, T, C)  is passed through the model's decoder, using weights and parameters learned during training.</p> </li> <li> <p>Decoder Components:</p> <ul> <li>Masked Multi-Head Attention: Computes attention over past tokens only, ensuring causality.</li> <li>Feed-Forward Neural Network (FFNN): Applies non-linear transformations to enrich token representations.</li> <li>Final Linear Layer: Maps the decoder output to logits (B,T,vocab_size)</li> </ul> </li> <li> <p>Softmax and Token Selection:</p> <ul> <li>The logits are passed through a softmax function to compute probabilities over the vocabulary.</li> <li>The token with the highest probability (or sampling) is chosen as the next token.</li> </ul> </li> </ol>"},{"location":"#73-iterative-process","title":"7.3. Iterative Process","text":"<ol> <li>Token Appending: The newly predicted token is appended to the input sequence, which grows in length: (B,T+1,C)</li> <li>Iteration: the process repeats until a stopping condition is met, such as reaching the maximum number of new tokens.</li> </ol>"},{"location":"#example-iterative-token-generation","title":"Example: Iterative Token Generation","text":"<ol> <li> <p>Initial Input:  </p> <ul> <li>Start with the input sequence, e.g., <code>\"dog\"</code> (token at position 0).  </li> <li>After tokenization and embedding, the input shape is  (B=1, T=1, C) , where  C  is the embedding dimension.</li> </ul> </li> <li> <p>First Iteration:  </p> <ul> <li>Pass the input tensor  (1, 1, C)  through the model.</li> <li>The model generates logits for position 1 with shape  (1, 1, \\text{vocab_size}) .</li> <li>Apply softmax to the logits to compute probabilities over the vocabulary.</li> <li>Use argmax or a sampling strategy to select the next token, e.g., \"jumps\" (index 1).</li> <li>Update: Append <code>\"jumps\"</code> to the sequence. The input tensor updates to  (1, 2) , and then transformed to (1,2,C) when fed to the model. </li> </ul> </li> <li> <p>Second Iteration:  </p> <ul> <li>Pass the updated sequence (<code>\"dog\", \"jumps\"</code>) with shape  (1, 2, C)  through the model.</li> <li>The model generates logits for position 2 with shape  (1, 2, \\text{vocab_size}) .</li> <li>Apply softmax, then argmax to select the next token, e.g., \"around\" (index 3).</li> <li>Update: Append <code>\"around\"</code> to the sequence. The input tensor updates to  (1, 3, C) .</li> </ul> </li> <li> <p>Repeat:  </p> <ul> <li>Continue passing the updated sequence through the model, generating logits for the next position, and appending the predicted token.</li> <li>The process continues until a stopping criterion is met, such as reaching a predefined sequence length.</li> </ul> </li> </ol>"},{"location":"#10-additionals-vanishing-gradients-exploding-gradients-and-regularization-techniques","title":"10. Additionals: Vanishing Gradients, Exploding Gradients, and Regularization Techniques","text":"<p>Gradients, computed during backpropagation, are the derivatives of the loss function with respect to model parameters (weights). They guide how much each parameter should change to minimize the loss. However, gradients can sometimes vanish or explode, causing training difficulties and poor model performance.</p> <ul> <li> <p>Vanishing Gradients: Gradients become very small as they propagate backward through the network, especially with activation functions like sigmoid or tanh. These functions saturate at high or low input values, producing near-zero gradients. Additionally, weights  W &lt; 1  during backpropagation shrink gradients exponentially, causing training to stall.</p> </li> <li> <p>Exploding Gradients: Conversely, gradients can grow excessively large ( W &gt; 1 ), leading to unstable training and erratic weight updates.</p> </li> </ul> <p>To stabilize training and improve gradient flow, several techniques are commonly used:</p> <ol> <li> <p>Weight Initialization: Proper initialization methods, like Xavier or He initialization, ensure gradients neither vanish nor explode during forward and backward passes.</p> </li> <li> <p>Activation Functions: ReLU avoids saturation by zeroing out negative values and maintaining constant gradients ( f'(x) = 1 ) for positive values. Variants like Leaky ReLU further improve gradient flow.</p> </li> <li> <p>Gradient Clipping: Limits the magnitude of gradients to a predefined threshold, preventing exploding gradients by capping excessively large values.</p> </li> <li> <p>Normalization Techniques:  </p> </li> <li>Layer Normalization stabilizes gradient flow by standardizing activations, helping to prevent both vanishing and exploding gradients.  </li> <li> <p>Batch Normalization reduces internal covariate shift, improving gradient stability.</p> </li> <li> <p>Regularization Techniques:  </p> </li> <li>Dropout: Randomly drops neurons during training, improving robustness and stabilizing gradient reliance.  </li> <li>Weight Decay: Penalizes large weights, mitigating exploding gradients.  </li> <li> <p>Learning Rate Schedulers: Gradually reduce the learning rate during training, ensuring smoother weight updates.</p> </li> <li> <p>Optimizers: Advanced optimizers like Adam adapt learning rates for each parameter, stabilizing gradient updates and improving convergence.</p> </li> </ol>"},{"location":"#8-references","title":"8. References:","text":"<ul> <li>Transformers Explained Visually (Part 2): How it works, step-by-step</li> <li>The Illustrated GPT-2 (Visualizing Transformer Language Models)</li> <li>Decoder-Only Transformers: The Workhorse of Generative LLMs</li> <li>Deep learning 13.3. Transformer Networks</li> <li>The Illustrated Transformer</li> <li>Attention Is All You Need</li> <li>How do Large Language Models learn?</li> </ul>"}]}